<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Block World</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }

        #instructions h3 {
            margin: 0 0 10px 0;
            color: #00ff00;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            z-index: 100;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            left: 50%;
            width: 2px;
            height: 20px;
            margin-left: -1px;
        }

        #crosshair::after {
            top: 50%;
            width: 20px;
            height: 2px;
            margin-top: -1px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h3>ðŸŽ® 3D Block World</h3>
        <p><strong>WASD</strong> - Move around</p>
        <p><strong>Mouse</strong> - Look around</p>
        <p><strong>Space</strong> - Jump</p>
        <p><strong>Click</strong> - Place/Remove blocks</p>
    </div>

    <div id="crosshair"></div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // 3D Game variables
        let scene, camera, renderer, raycaster;
        let player = { x: 5, y: 2, z: 5 };
        let velocity = { x: 0, y: 0, z: 0 };
        let blocks = [];
        let keys = {};
        let mouse = new THREE.Vector2();
        let isPointerLocked = false;

        // Initialize 3D world
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(player.x, player.y, player.z);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create raycaster for block placement
            raycaster = new THREE.Raycaster();

            // Build initial world
            createWorld();
            setupControls();
            animate();
        }

        // Create the block world
        function createWorld() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // Green
                new THREE.MeshLambertMaterial({ color: 0x8B4513 }), // Brown
                new THREE.MeshLambertMaterial({ color: 0x808080 }), // Gray
            ];

            // Create ground platform (10x10 grid)
            for (let x = 0; x < 15; x++) {
                for (let z = 0; z < 15; z++) {
                    const block = new THREE.Mesh(geometry, materials[0]);
                    block.position.set(x, 0, z);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    scene.add(block);
                    blocks.push({ mesh: block, x: x, y: 0, z: z });
                }
            }

            // Add some random blocks for variety
            for (let i = 0; i < 20; i++) {
                const x = Math.floor(Math.random() * 15);
                const z = Math.floor(Math.random() * 15);
                const y = Math.floor(Math.random() * 3) + 1;
                const material = materials[Math.floor(Math.random() * materials.length)];
                
                const block = new THREE.Mesh(geometry, material);
                block.position.set(x, y, z);
                block.castShadow = true;
                block.receiveShadow = true;
                scene.add(block);
                blocks.push({ mesh: block, x: x, y: y, z: z });
            }
        }

        // Setup controls
        function setupControls() {
            // Keyboard events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse events
            document.addEventListener('click', requestPointerLock);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function requestPointerLock() {
            renderer.domElement.requestPointerLock();
        }

        function onPointerLockChange() {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;

            const sensitivity = 0.002;
            camera.rotation.y -= event.movementX * sensitivity;
            camera.rotation.x -= event.movementY * sensitivity;
            camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }

        function onMouseDown(event) {
            if (!isPointerLocked) return;

            // Cast ray to find blocks
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const blockPos = intersect.object.position;

                if (event.button === 0) { // Left click - remove block
                    if (blockPos.y > 0) { // Don't remove ground blocks
                        scene.remove(intersect.object);
                        blocks = blocks.filter(b => b.mesh !== intersect.object);
                    }
                } else if (event.button === 2) { // Right click - add block
                    const normal = intersect.face.normal;
                    const newPos = blockPos.clone().add(normal);
                    
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: Math.random() * 0xffffff 
                    });
                    const newBlock = new THREE.Mesh(geometry, material);
                    newBlock.position.copy(newPos);
                    newBlock.castShadow = true;
                    newBlock.receiveShadow = true;
                    scene.add(newBlock);
                    blocks.push({ mesh: newBlock, x: newPos.x, y: newPos.y, z: newPos.z });
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Update player movement
        function updatePlayer() {
            const speed = 0.1;
            const jumpForce = 0.15;

            // Movement based on camera direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));

            if (keys['KeyW']) {
                velocity.x += direction.x * speed;
                velocity.z += direction.z * speed;
            }
            if (keys['KeyS']) {
                velocity.x -= direction.x * speed;
                velocity.z -= direction.z * speed;
            }
            if (keys['KeyA']) {
                velocity.x -= right.x * speed;
                velocity.z -= right.z * speed;
            }
            if (keys['KeyD']) {
                velocity.x += right.x * speed;
                velocity.z += right.z * speed;
            }
            if (keys['Space'] && player.y <= 2.1) {
                velocity.y = jumpForce;
            }

            // Apply gravity
            velocity.y -= 0.01;

            // Update player position
            player.x += velocity.x;
            player.y += velocity.y;
            player.z += velocity.z;

            // Ground collision (simple)
            if (player.y < 2) {
                player.y = 2;
                velocity.y = 0;
            }

            // Keep player in bounds
            player.x = Math.max(0, Math.min(14, player.x));
            player.z = Math.max(0, Math.min(14, player.z));

            // Apply friction
            velocity.x *= 0.8;
            velocity.z *= 0.8;

            // Update camera position
            camera.position.set(player.x, player.y, player.z);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }

        // Prevent right-click menu
        document.addEventListener('contextmenu', e => e.preventDefault());

        // Start the game
        init();
    </script>
</body>
</html>